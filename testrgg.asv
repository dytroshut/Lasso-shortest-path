%% RGG + InADMM (weighted LASSO) — black-background fancy plot
% Same fast InADMM (exact inner solve via AMD + sparse Cholesky).
% Only plotting is changed to a dark theme: faint bright base edges + vivid red path (with halo).
clear; clc; close all;

%% ---------------- User controls ----------------
n                = 6000;     % nodes uniform in [0,1]^2
TARGET_GC_FRAC   = 0.98;
MAX_ITERS_RADIUS = 20;
R_INFLATE        = 1.18;

alpha     = 2;               % base weights: w0 = d^alpha
ADD_NOISE = true;
mu_rel    = 2e-2;            % multiplicative jitter: w <- w .* (1 + mu_rel*U[0,1])
nu_rel    = 1e-3;            % additive jitter:       w <- w + nu_rel*max(w)*U[0,1]
tie_rel   = 1e-12;           % deterministic weight tie-break (added after noise)

% ℓ1 penalty tie-break (weighted LASSO): λ_j = λ * (1 + penalty_tie_rel * ξ_j)
penalty_tie_rel = 1e-8;

% LASSO settings
lambda_scale = 1e-7;         % λ = lambda_scale * λ_max  (smaller => more edges)

% InADMM options (unchanged)
opts.rho     = 1.0;
opts.alpha   = 1.8;
opts.maxit   = 50000;
opts.abstol  = 1e-8;
opts.reltol  = 1e-6;
opts.verbose = true;

% Plot styling (dark theme)
NODE_SIZE_SMALL  = 1.2;
BASE_EDGE_COL    = [0.90 0.94 1.00];   % bright bluish-gray on black
BASE_EDGE_ALPHA  = 0.35;
BASE_EDGE_WIDTH  = 0.9;
PATH_EDGE_WIDTH  = 4.0;
RED_PATH         = [1.00 0.15 0.15];   % vivid red
HALO_ON          = true;
HALO_COL         = [1 1 1]*0.92;       % soft white halo
HALO_EXTRA       = 2.5;                % halo thickness

% Display threshold for InADMM (|z| >= thr_abs)
thr_abs = 3e-5;

rng(42);   % reproducible

%% ---------------- Sample node positions ----------------
X = rand(n,1); Y = rand(n,1);

%% ---------------- Radius: grow until giant comp meets target ---------------
r = sqrt( max(log(n),1) / (pi*n) );
r = min(max(r, 1e-4), sqrt(2));
r = 1.1*r;

G = [];
for it = 1:MAX_ITERS_RADIUS
    [I,J] = rgg_edges_radius(X, Y, r);
    Gtmp  = graph(I, J, [], n);
    comp  = conncomp(Gtmp);
    sz    = accumarray(comp',1,[max(comp),1]);
    gc    = max(sz)/n;
    fprintf('  r-iter %2d: r=%.4g, edges=%d, giant frac=%.2f%%\n', it, r, numedges(Gtmp), 100*gc);
    if gc >= TARGET_GC_FRAC, G = Gtmp; break; else, r = min(R_INFLATE*r, sqrt(2)); end
end
if isempty(G), warning('Using last graph (target GC not reached).'); G = Gtmp; end

% Keep giant component
comp = conncomp(G);
sz   = accumarray(comp',1,[max(comp),1]);
[~, gid] = max(sz);
keep = (comp == gid);
G = subgraph(G, keep);
Xg = X(keep); Yg = Y(keep);

ng = numnodes(G); m = numedges(G);
fprintf('Kept giant component: n=%d, m=%d (final r=%.4g)\n', ng, m, r);

%% ---------------- Weights: base + jitter + tie-break -----------------------
EN   = G.Edges.EndNodes; sIdx = EN(:,1); tIdx = EN(:,2);
d    = hypot(Xg(sIdx)-Xg(tIdx), Yg(sIdx)-Yg(tIdx));
w0   = max(d, eps).^alpha;

if ADD_NOISE
    M     = max(w0);
    xi1   = rand(m,1);                    % multiplicative U[0,1]
    xi2   = rand(m,1);                    % additive      U[0,1]
    w_n   = w0 .* (1 + mu_rel*xi1) + (nu_rel*M)*xi2;
else
    w_n   = w0;
end
w_n(w_n<=0) = eps;

% tiny deterministic tie-break (removes residual ties)
w = add_tiebreak(w_n, sIdx, tIdx, tie_rel);
G.Edges.Weight = w;

%% ---------------- s (left-most) & t (farthest reachable) -------------------
rx = (Xg - min(Xg))/max(1e-12, max(Xg)-min(Xg));
[~, start_node] = min(rx);
distAll = distances(G, start_node);               % weighted by w
cands   = find(isfinite(distAll)); cands(cands==start_node) = [];
[~, jj] = max(distAll(cands));
end_node = cands(jj);

%% ---------------- Build Q = D W^{-1}, y = e_s - e_t -----------------------
I_D = [sIdx;  tIdx]; J_D = [(1:m)'; (1:m)']; V_D = [ones(m,1); -ones(m,1)];
D   = sparse(I_D, J_D, V_D, ng, m);
Q   = D * spdiags(1./w, 0, m, m);

y = sparse(ng,1); y(start_node)=1; y(end_node)=-1;

%% ---------------- λ and per-edge λ_j (penalty tie-break) -------------------
lambda_max = norm(Q'*y, inf);
lambda     = lambda_scale * lambda_max;
tau = 1 + penalty_tie_rel * edge_hash01(sIdx, tIdx);   % in (1, 1+ε)
lambda_vec = lambda * tau;

fprintf('lambda_max=%.3e, lambda=%.3e, mu_rel=%.1e, nu_rel=%.1e, tie_rel=%.1e, penalty_tie_rel=%.1e\n',...
        lambda_max, lambda, mu_rel, nu_rel, tie_rel, penalty_tie_rel);

%% ---------------- InADMM (weighted LASSO, exact inner solve) ---------------
[z0,v0,a0] = deal(zeros(m,1));
[zIN, aIN, vIN, histIN] = inadmm_lasso_weighted_direct(Q, y, lambda_vec, opts, z0, a0, v0, sIdx, tIdx, w);

%% ---------------- Plot: black background + red path w/ halo ----------------
eIN = find(abs(zIN) >= thr_abs);
fprintf('InADMM: iters=%d, r=%.2e, s=%.2e, obj=%.4e, selected edges=%d/%d\n', ...
        histIN.iters, histIN.rnorm(end), histIN.snorm(end), histIN.obj(end), numel(eIN), m);

% Base graph on black
[ax, p] = base_plot_dark(G, Xg, Yg, NODE_SIZE_SMALL, BASE_EDGE_COL, BASE_EDGE_ALPHA, BASE_EDGE_WIDTH);

% Red path overlay (with optional white halo)
if ~isempty(eIN)
    highlight_edges_dark(ax, Xg, Yg, sIdx, tIdx, eIN, PATH_EDGE_WIDTH, RED_PATH, HALO_ON, HALO_COL, HALO_EXTRA);
end
    %highlight_edges_dark(ax, Xg, Yg, sIdx, tIdx, eIN, PATH_EDGE_WIDTH, RED_PATH, HALO_ON, HALO_COL, HALO_EXTRA);
end
mark_st_dark(ax, Xg, Yg, start_node, end_node);
%title(ax, sprintf('RGG — InADMM edges with |z| \\ge %.1e (n=%d, m=%d)', thr_abs, ng, m), ...
    %'Color', [1 1 1], 'FontWeight','bold');

%% ---------------- Convergence (default white) -------------------
plot_history(histIN, 'InADMM (direct solve)');

%% =================== Helpers ===================

function [I,J] = rgg_edges_radius(X,Y,r)
% Return undirected edges (i<j) for all pairs within radius r.
    n = numel(X); I = []; J = [];
    if exist('createns','file')==2 && exist('rangesearch','file')==2
        ns  = createns([X Y],'NSMethod','kdtree');
        idx = rangesearch(ns, [X Y], r);
        for i=1:n
            nbrs = idx{i};
            nbrs = nbrs(nbrs > i);
            if ~isempty(nbrs)
                I = [I; i*ones(numel(nbrs),1)];
                J = [J; nbrs(:)];
            end
        end
    elseif exist('pdist','file')==2 && exist('squareform','file')==2
        D = squareform(pdist([X Y]));
        [ii,jj] = find(triu(D <= r, 1));
        I = ii; J = jj;
    else
        blk = 1000;
        for i1=1:blk:n
            i2 = min(n, i1+blk-1);
            Xi = X(i1:i2); Yi = Y(i1:i2);
            for j1=i1:blk:n
                j2 = min(n, j1+blk-1);
                Xj = X(j1:j2)'; Yj = Y(j1:j2)';
                Dx = Xi - Xj; Dy = Yi - Yj;
                D2 = hypot(Dx, Dy) <= r;
                if i1==j1, D2 = triu(D2,1); end
                [ii,jj] = find(D2);
                I = [I; (i1-1)+ii];
                J = [J; (j1-1)+jj];
            end
        end
    end
end

function wU = add_tiebreak(w, sIdx, tIdx, rel)
% Tiny deterministic tie-break scaled to max(w)
    w = double(w(:));
    M = max(w(~isinf(w))); if isempty(M), M = 1; end
    eps0 = rel * M;
    phi  = sin(double(sIdx).*12.9898 + double(tIdx).*78.233);
    tb   = abs((phi*43758.5453) - floor(phi*43758.5453)); % [0,1)
    wU   = w + eps0*tb;
end

function h = edge_hash01(sIdx,tIdx)
% Deterministic pseudo-random in [0,1) per edge
    phi = sin(double(sIdx).*12.9898 + double(tIdx).*78.233);
    h   = abs((phi*43758.5453) - floor(phi*43758.5453));
end

%% ======== Dark plotting helpers ===========================================
function [ax, p] = base_plot_dark(G, X, Y, nodeDotSize, baseCol, baseAlpha, baseLW)
    fig = figure('Color','k'); %#ok<NASGU>
    ax = axes('Color','k'); hold(ax,'on'); axis(ax,'equal','off');
    p = plot(ax, G, ...
        'XData', X, 'YData', Y, ...
        'NodeLabel', {}, ...
        'NodeColor', [0.75 0.75 0.75], ...    % faint grey dots
        'Marker', '.', 'MarkerSize', nodeDotSize, ...
        'EdgeColor', baseCol, 'EdgeAlpha', baseAlpha, 'LineWidth', baseLW);
end

function highlight_edges_dark(ax, X, Y, sIdx, tIdx, eList, lineW, edgeCol, haloOn, haloCol, haloExtra)
    if isempty(eList), return; end
    k  = numel(eList);
    XE = [X(sIdx(eList))'; X(tIdx(eList))'; nan(1,k)]; XE = XE(:);
    YE = [Y(sIdx(eList))'; Y(tIdx(eList))'; nan(1,k)]; YE = YE(:);

    % halo first (underlay)
    if haloOn
        plot(ax, XE, YE, '-', 'LineWidth', lineW + haloExtra, 'Color', haloCol); 
        hold(ax,'on');
    end

    % main red stroke
    plot(ax, XE, YE, '-', 'LineWidth', lineW, 'Color', edgeCol);
    hold(ax,'on');
end

function mark_st_dark(ax, X, Y, s, t)
    plot(ax, X([s t]),Y([s t]),'wo','MarkerFaceColor','k','MarkerSize',7,'LineWidth',1.2);
    text(ax, X(s),Y(s),'  s','FontWeight','bold','FontSize',13,'Color','w');
    text(ax, X(t),Y(t),'  t','FontWeight','bold','FontSize',13,'Color','w');
end

%% ======== Convergence plot (unchanged) =====================================
function plot_history(H, name)
    figure('Color','w');
    subplot(2,1,1);
    semilogy(1:numel(H.rnorm), H.rnorm,'-','LineWidth',1.4); hold on;
    semilogy(1:numel(H.snorm), H.snorm,'--','LineWidth',1.4);
    grid on; legend('primal r','dual s','Location','southwest');
    xlabel('iteration'); ylabel('residual'); title([name ' residuals']);
    subplot(2,1,2);
    semilogy(1:numel(H.obj), H.obj,'-','LineWidth',1.4); grid on;
    xlabel('iteration'); ylabel('objective'); title([name ' objective']);
end

%% ======== InADMM (direct z-update via (QQ'+ρI)^{-1} and decomposition) =====
function [z, a, v, hist] = inadmm_lasso_weighted_direct(Q, y, lambda_vec, opts, z0, a0, v0, sIdx, tIdx, w)
% Exact inner solve: (QQ' + rho I) eta = Q h, solved by AMD + sparse Cholesky.
    rho     = opts.rho;
    alpha   = getf(opts,'alpha',1.8);
    maxit   = opts.maxit;
    abstol  = opts.abstol;
    reltol  = opts.reltol;
    verbose = getf(opts,'verbose',false);

    [n,m] = size(Q); z=z0; a=a0; v=v0; lamv=lambda_vec(:);
    rhs0 = Q'*y;

    % QQ' as weighted Laplacian + rho*I (no explicit Q*Q')
    w2  = 1./(w(:).^2);
    Ii  = sIdx(:); Jj = tIdx(:);
    L   = sparse(n,n);
    L = L + sparse(Ii,Ii,w2,n,n) + sparse(Jj,Jj,w2,n,n) ...
          - sparse(Ii,Jj,w2,n,n) - sparse(Jj,Ii,w2,n,n);
    L = L + rho*speye(n);

    % AMD + sparse Cholesky (once)
    p   = symamd(L); Lp = L(p,p); dL = decomposition(Lp,'chol');
    Qp  = Q(p,:);

    hist.rnorm=zeros(1,maxit); hist.snorm=zeros(1,maxit); hist.obj=zeros(1,maxit); hist.iters=0;

    for k=1:maxit
        h     = rhs0 + rho*(a - v);
        b_p   = Qp * h;                % permuted RHS
        eta_p = dL \ b_p;              % solve (QQ'+rho I) eta = Q h
        eta   = zeros(n,1); eta(p) = eta_p;

        z = (1/rho) * (h - Q' * eta);

        z_hat = alpha*z + (1-alpha)*a;
        a_old = a;
        a     = soft_vec(z_hat + v, lamv/rho);   % elementwise λ_j/ρ
        v     = v + (z_hat - a);

        r = z - a; s = rho*(a - a_old);
        rnorm=norm(r); snorm=norm(s);
        eps_p = sqrt(m)*abstol + reltol*max(norm(z), norm(a));
        eps_d = sqrt(m)*abstol + reltol*norm(rho*v);
        hist.rnorm(k)=rnorm; hist.snorm(k)=snorm;
        hist.obj(k)=0.5*norm(Q*z - y)^2 + sum(lamv.*abs(z));
        hist.iters=k;

        if verbose && (mod(k,50)==0 || k==1)
            fprintf('InADMM %4d  r=%.2e  s=%.2e  obj=%.4e\n',k,rnorm,snorm,hist.obj(k));
        end
        if (rnorm<=eps_p) && (snorm<=eps_d), break; end
    end

    hist.rnorm=hist.rnorm(1:hist.iters);
    hist.snorm=hist.snorm(1:hist.iters);
    hist.obj  =hist.obj(1:hist.iters);
end

% --- small utilities ---
function z = soft_vec(x,tau), z = sign(x).*max(abs(x)-tau,0); end
function val = getf(s,f,def), if isfield(s,f), val=s.(f); else, val=def; end, end






% %% RGG + InADMM (weighted LASSO) — uniqueness via weight jitter & penalty tie-break
% clear; clc; close all;
% 
% %% ---------------- User controls ----------------
% n                = 6000;     % nodes in [0,1]^2
% TARGET_GC_FRAC   = 0.98;
% MAX_ITERS_RADIUS = 20;
% R_INFLATE        = 1.18;
% 
% alpha     = 2;               % base weights: w0 = d^alpha
% ADD_NOISE = true;
% mu_rel    = 2e-2;            % multiplicative jitter: w <- w .* (1 + mu_rel*U[0,1])
% nu_rel    = 1e-3;            % additive jitter:       w <- w + nu_rel*max(w)*U[0,1]
% tie_rel   = 1e-12;           % deterministic weight tie-break (added after noise)
% 
% % ℓ1 penalty tie-break (weighted LASSO): λ_j = λ * (1 + penalty_tie_rel * ξ_j)
% penalty_tie_rel = 1e-8;
% 
% % LASSO settings
% lambda_scale = 1e-7;         % λ = lambda_scale * λ_max  (smaller => more edges)
% 
% % InADMM options
% opts.rho     = 1.0;
% opts.alpha   = 1.8;          % keep same style as your ADMM printouts
% opts.maxit   = 50000;
% opts.abstol  = 1e-8;
% opts.reltol  = 1e-6;
% opts.verbose = true;         % print progress (every 50 iters, + first)
% 
% % Plot styling
% NODE_SIZE_SMALL  = 1.2;
% BASE_EDGE_ALPHA  = 0.55;
% BASE_EDGE_WIDTH  = 0.9;
% PATH_EDGE_WIDTH  = 4.0;
% CLR_IN = [0 0.45 0];         % dark green
% 
% % Display threshold for InADMM edges (no post shortest-path)
% thr_abs = 3e-5;
% 
% rng(42);
% 
% %% ---------------- Sample node positions ----------------
% X = rand(n,1); Y = rand(n,1);
% 
% %% ---------------- Radius: grow until giant comp meets target ---------------
% r = sqrt( max(log(n),1) / (pi*n) );
% r = min(max(r, 1e-4), sqrt(2));
% r = 1.1*r;
% 
% G = [];
% for it = 1:MAX_ITERS_RADIUS
%     [I,J] = rgg_edges_radius(X, Y, r);
%     Gtmp  = graph(I, J, [], n);
%     comp  = conncomp(Gtmp);
%     sz    = accumarray(comp',1,[max(comp),1]);
%     gc    = max(sz)/n;
%     fprintf('  r-iter %2d: r=%.4g, edges=%d, giant frac=%.2f%%\n', it, r, numedges(Gtmp), 100*gc);
%     if gc >= TARGET_GC_FRAC, G = Gtmp; break; else, r = min(R_INFLATE*r, sqrt(2)); end
% end
% if isempty(G), warning('Using last graph (target GC not reached).'); G = Gtmp; end
% 
% % Keep giant component
% comp = conncomp(G);
% sz   = accumarray(comp',1,[max(comp),1]);
% [~, gid] = max(sz);
% keep = (comp == gid);
% G = subgraph(G, keep);
% Xg = X(keep); Yg = Y(keep);
% 
% ng = numnodes(G); m = numedges(G);
% fprintf('Kept giant component: n=%d, m=%d (final r=%.4g)\n', ng, m, r);
% 
% %% ---------------- Weights: base + multiplicative/additive jitter + tie-break
% EN   = G.Edges.EndNodes; sIdx = EN(:,1); tIdx = EN(:,2);
% d    = hypot(Xg(sIdx)-Xg(tIdx), Yg(sIdx)-Yg(tIdx));
% w0   = max(d, eps).^alpha;
% 
% if ADD_NOISE
%     M     = max(w0);
%     xi1   = rand(m,1);                    % multiplicative U[0,1]
%     xi2   = rand(m,1);                    % additive      U[0,1]
%     w_n   = w0 .* (1 + mu_rel*xi1) + (nu_rel*M)*xi2;
% else
%     w_n   = w0;
% end
% w_n(w_n<=0) = eps;
% 
% % deterministic tie-break in weights (to kill residual ties)
% w = add_tiebreak(w_n, sIdx, tIdx, tie_rel);
% G.Edges.Weight = w;
% 
% %% ---------------- s (left-most) & t (farthest reachable) -------------------
% rx = (Xg - min(Xg))/max(1e-12, max(Xg)-min(Xg));
% [~, start_node] = min(rx);
% distAll = distances(G, start_node);         % uses current w
% cands   = find(isfinite(distAll)); cands(cands==start_node) = [];
% [~, jj] = max(distAll(cands));
% end_node = cands(jj);
% 
% %% ---------------- Build Q = D W^{-1}, y = e_s - e_t -----------------------
% I_D = [sIdx;  tIdx]; J_D = [(1:m)'; (1:m)']; V_D = [ones(m,1); -ones(m,1)];
% D   = sparse(I_D, J_D, V_D, ng, m);
% Q   = D * spdiags(1./w, 0, m, m);
% 
% y = sparse(ng,1); y(start_node)=1; y(end_node)=-1;
% 
% %% ---------------- λ and per-edge λ_j (penalty tie-break) -------------------
% lambda_max = norm(Q'*y, inf);
% lambda     = lambda_scale * lambda_max;
% % tiny per-edge variations in the ℓ1 penalty (forces a unique minimizer)
% tau = 1 + penalty_tie_rel * edge_hash01(sIdx, tIdx);   % in (1, 1+ε)
% lambda_vec = lambda * tau;
% 
% fprintf('lambda_max=%.3e, lambda=%.3e, mu_rel=%.1e, nu_rel=%.1e, tie_rel=%.1e, penalty_tie_rel=%.1e\n',...
%         lambda_max, lambda, mu_rel, nu_rel, tie_rel, penalty_tie_rel);
% 
% %% ---------------- InADMM (weighted LASSO, direct solve) --------------------
% [z0,v0,a0] = deal(zeros(m,1));
% [zIN, aIN, vIN, histIN] = inadmm_lasso_weighted_direct(Q, y, lambda_vec, opts, z0, a0, v0, sIdx, tIdx, w);
% 
% %% ---------------- Plot: base + InADMM support ------------------------------
% eIN = find(abs(zIN) >= thr_abs);
% fprintf('InADMM: iters=%d, r=%.2e, s=%.2e, obj=%.4e, selected edges=%d/%d\n', ...
%         histIN.iters, histIN.rnorm(end), histIN.snorm(end), histIN.obj(end), numel(eIN), m);
% 
% figure('Color','w'); 
% p = base_plot(G, Xg, Yg, NODE_SIZE_SMALL, BASE_EDGE_ALPHA, BASE_EDGE_WIDTH);
% if ~isempty(eIN)
%     highlight(p, 'Edges', eIN, 'LineWidth', PATH_EDGE_WIDTH, 'EdgeColor', CLR_IN);
% end
% mark_st(Xg, Yg, start_node, end_node);
% title(sprintf('RGG — InADMM edges with |z| \\ge %.1e (n=%d, m=%d)', thr_abs, ng, m));
% 
% %% ---------------- Convergence -------------------
% plot_history(histIN, 'InADMM (direct solve)');
% 
% %% =================== Helpers ===================
% 
% function [I,J] = rgg_edges_radius(X,Y,r)
% % Return undirected edges (i<j) for all pairs within radius r.
%     n = numel(X); I = []; J = [];
%     if exist('createns','file')==2 && exist('rangesearch','file')==2
%         ns  = createns([X Y],'NSMethod','kdtree');
%         idx = rangesearch(ns, [X Y], r);
%         for i=1:n
%             nbrs = idx{i};
%             nbrs = nbrs(nbrs > i);
%             if ~isempty(nbrs)
%                 I = [I; i*ones(numel(nbrs),1)];
%                 J = [J; nbrs(:)];
%             end
%         end
%     elseif exist('pdist','file')==2 && exist('squareform','file')==2
%         D = squareform(pdist([X Y]));
%         [ii,jj] = find(triu(D <= r, 1));
%         I = ii; J = jj;
%     else
%         blk = 1000;
%         for i1=1:blk:n
%             i2 = min(n, i1+blk-1);
%             Xi = X(i1:i2); Yi = Y(i1:i2);
%             for j1=i1:blk:n
%                 j2 = min(n, j1+blk-1);
%                 Xj = X(j1:j2)'; Yj = Y(j1:j2)';
%                 Dx = Xi - Xj; Dy = Yi - Yj;
%                 D2 = hypot(Dx, Dy) <= r;
%                 if i1==j1, D2 = triu(D2,1); end
%                 [ii,jj] = find(D2);
%                 I = [I; (i1-1)+ii];
%                 J = [J; (j1-1)+jj];
%             end
%         end
%     end
% end
% 
% function wU = add_tiebreak(w, sIdx, tIdx, rel)
%     w = double(w(:));
%     M = max(w(~isinf(w))); if isempty(M), M = 1; end
%     eps0 = rel * M;
%     phi  = sin(double(sIdx)*12.9898 + double(tIdx)*78.233);
%     tb   = abs((phi*43758.5453) - floor(phi*43758.5453)); % [0,1)
%     wU   = w + eps0*tb;
% end
% 
% function h = edge_hash01(sIdx,tIdx)
% % Deterministic pseudo-random in [0,1) per edge
%     phi = sin(double(sIdx)*12.9898 + double(tIdx)*78.233);
%     h   = abs((phi*43758.5453) - floor(phi*43758.5453));
% end
% 
% function p = base_plot(G,X,Y,nodeSize,edgeAlpha,edgeWidth)
%     p = plot(G, ...
%         'XData', X, 'YData', Y, ...
%         'NodeLabel', {}, ...
%         'NodeColor', 'k', ...
%         'Marker', '.', ...
%         'MarkerSize', nodeSize, ...
%         'EdgeColor', [0 0.4470 0.7410], ...
%         'EdgeAlpha', edgeAlpha, ...
%         'LineWidth', edgeWidth);
%     axis equal off; hold on;
% end
% 
% function mark_st(X,Y,s,t)
%     plot(X([s t]),Y([s t]),'ko','MarkerFaceColor','w','MarkerSize',6);
%     text(X(s),Y(s),'  s','FontWeight','bold','Color','k');
%     text(X(t),Y(t),'  t','FontWeight','bold','Color','k');
% end
% 
% function plot_history(H, name)
%     figure('Color','w');
%     subplot(2,1,1);
%     semilogy(1:numel(H.rnorm), H.rnorm,'-','LineWidth',1.4); hold on;
%     semilogy(1:numel(H.snorm), H.snorm,'--','LineWidth',1.4);
%     grid on; legend('primal r','dual s','Location','southwest');
%     xlabel('iteration'); ylabel('residual'); title([name ' residuals']);
%     subplot(2,1,2);
%     semilogy(1:numel(H.obj), H.obj,'-','LineWidth',1.4); grid on;
%     xlabel('iteration'); ylabel('objective'); title([name ' objective']);
% end
% 
% %% ======== InADMM (direct z-update via (QQ'+ρI)^{-1} and decomposition) =====
% function [z, a, v, hist] = inadmm_lasso_weighted_direct(Q, y, lambda_vec, opts, z0, a0, v0, sIdx, tIdx, w)
% % InADMM with an exact inner solve:
% %   (QQ' + rho I) eta = Q h
% % solved by a sparse Cholesky (decomposition('chol')) with AMD reordering.
% % The factor is built once (rho fixed). Per-iteration logs mirror your ADMM.
% 
%     rho     = opts.rho;
%     alpha   = getf(opts,'alpha',1.8);
%     maxit   = opts.maxit;
%     abstol  = opts.abstol;
%     reltol  = opts.reltol;
%     verbose = getf(opts,'verbose',false);
% 
%     [n,m] = size(Q); z=z0; a=a0; v=v0; lamv=lambda_vec(:);
%     rhs0 = Q'*y;
% 
%     % ---- Build L = QQ' + rho I without forming Q*Q' explicitly (as Laplacian) ----
%     % Q = D * W^{-1}  => QQ' = D * W^{-2} * D'
%     w2  = 1./(w(:).^2);
%     Ii  = sIdx(:); Jj = tIdx(:);
%     L   = sparse(n,n);
%     L = L + sparse(Ii,Ii,w2,n,n) + sparse(Jj,Jj,w2,n,n) ...
%           - sparse(Ii,Jj,w2,n,n) - sparse(Jj,Ii,w2,n,n);
%     L = L + rho*speye(n);
% 
%     % AMD reordering and Cholesky factorization (once)
%     p   = symamd(L);
%     Lp  = L(p,p);
%     dL  = decomposition(Lp,'chol');   % robust sparse Cholesky
%     Qp  = Q(p,:);                     % permuted Q for RHS each iteration
% 
%     % History
%     hist.rnorm=zeros(1,maxit); hist.snorm=zeros(1,maxit); hist.obj=zeros(1,maxit); hist.iters=0;
% 
%     for k=1:maxit
%         % z-update via the identity and direct solve
%         h    = rhs0 + rho*(a - v);
%         b_p  = Qp * h;                % permuted RHS
%         eta_p = dL \ b_p;             % solve (QQ'+rho I) eta = Q h
%         eta   = zeros(n,1); eta(p) = eta_p;
% 
%         z = (1/rho) * (h - Q' * eta);
% 
%         % a,v updates
%         z_hat = alpha*z + (1-alpha)*a;
%         a_old = a;
%         a     = soft_vec(z_hat + v, lamv/rho);   % elementwise λ_j/ρ
%         v     = v + (z_hat - a);
% 
%         % residuals & stopping
%         r = z - a; s = rho*(a - a_old);
%         rnorm=norm(r); snorm=norm(s);
%         eps_p = sqrt(m)*abstol + reltol*max(norm(z), norm(a));
%         eps_d = sqrt(m)*abstol + reltol*norm(rho*v);
%         hist.rnorm(k)=rnorm; hist.snorm(k)=snorm;
%         hist.obj(k)=0.5*norm(Q*z - y)^2 + sum(lamv.*abs(z));
%         hist.iters=k;
% 
%         if verbose && (mod(k,50)==0 || k==1)
%             fprintf('InADMM %4d  r=%.2e  s=%.2e  obj=%.4e\n',k,rnorm,snorm,hist.obj(k));
%         end
%         if (rnorm<=eps_p) && (snorm<=eps_d), break; end
%     end
% 
%     hist.rnorm=hist.rnorm(1:hist.iters);
%     hist.snorm=hist.snorm(1:hist.iters);
%     hist.obj  =hist.obj(1:hist.iters);
% end
% 
% % --- small utilities ---
% function z = soft_vec(x,tau), z = sign(x).*max(abs(x)-tau,0); end
% function val = getf(s,f,def), if isfield(s,f), val=s.(f); else, val=def; end, end